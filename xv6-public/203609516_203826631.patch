diff --git a/LICENSE b/LICENSE
index d4b5af9..46fd1cc 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,6 +1,6 @@
 The xv6 software is:
 
-Copyright (c) 2006-2016 Frans Kaashoek, Robert Morris, Russ Cox,
+Copyright (c) 2006-2009 Frans Kaashoek, Robert Morris, Russ Cox,
                         Massachusetts Institute of Technology
 
 Permission is hereby granted, free of charge, to any person obtaining
diff --git a/Makefile b/Makefile
index a635b64..0f29ea0 100644
--- a/Makefile
+++ b/Makefile
@@ -15,6 +15,7 @@ OBJS = \
 	picirq.o\
 	pipe.o\
 	proc.o\
+	kthread.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
@@ -167,6 +168,15 @@ UPROGS=\
 	_ls\
 	_mkdir\
 	_rm\
+	_mt\
+	_htest\
+	_ttest\
+	_mtest\
+	_cowtest\
+	_fssp\
+	_threadtest\
+	_threadtest1\
+	_threadtest4\
 	_sh\
 	_stressfs\
 	_usertests\
@@ -208,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -240,7 +250,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c htest.c mtest.c fssp.c ttest.c mt.c threadtest.c threadtest1.c threadtest2.c threadtest4.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/README b/README
index 89b9d8f..e561966 100644
--- a/README
+++ b/README
@@ -32,12 +32,8 @@ Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
 
 ERROR REPORTS
 
-If you spot errors or have suggestions for improvement, please send email to
-Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu).  If you have
-suggestions for improvements, please keep in mind that the main purpose of xv6
-is as a teaching operating systems for MIT's 6.828. For example, we are in
-particular interested in simplifications and clarifications, instead of
-suggestions for new systems calls, more portability, etc.
+If you spot errors or have suggestions for improvement, please send
+email to Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu).
 
 BUILDING AND RUNNING XV6
 
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..5122b2c
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# Assignment2
diff --git a/console.c b/console.c
index fa611ef..d05450d 100644
--- a/console.c
+++ b/console.c
@@ -241,7 +241,7 @@ consoleread(struct inode *ip, char *dst, int n)
   acquire(&cons.lock);
   while(n > 0){
     while(input.r == input.w){
-      if(proc->killed){
+      if(proc->killed||proc->executed){
         release(&cons.lock);
         ilock(ip);
         return -1;
diff --git a/cowtest.c b/cowtest.c
new file mode 100644
index 0000000..16164c5
--- /dev/null
+++ b/cowtest.c
@@ -0,0 +1,50 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+
+
+void
+cow_demo()
+{
+   int pid = getpid();
+   int *x = (int *)malloc(sizeof(int));
+   int *grade = (int*)malloc(sizeof(int));
+   *grade = 100;
+   *x = 0;
+   int *y = (int *)malloc(sizeof(int));
+   *y = 100; // GRADE?!#!##$
+
+   printf(1, "pid : %d x: %d y: %d grade: %d \n\n", pid, *x, *y, *grade);
+   printf(1, "Fater Process <procdump> Before Forking \n\n");
+   //output will be from page 1 and we can see that there is a readonly page.
+   procdump();
+
+   //child
+   if (forkcow() == 0)
+   {
+
+     printf(1, "CHILD before changing X same address -copied\n");
+     printf(1,"pid is : %d x:  %d y: %d, grade: %d \n\n", getpid(), *x, *y, *grade);
+     procdump();
+     *x=2;
+     printf(1, "CHILD after changing X same address\n");
+     printf(1,"pid is : %d x:  %d y: %d, grade: %d \n\n", getpid(), *x, *y, *grade);
+     procdump();
+//     // now we can see that before changing x it was a shared memory
+//     printf(1,"pid is : %d x: %d , y: %d, grade: %d \n\n\n\n", getpid(), *x, *y, *grade);
+   } else {
+       waitcow();
+       printf(1, "Fater Process <procdump> After Cow_Forking \n\n");
+       procdump();
+   }
+   exit();
+}
+int
+main(int argc, char *argv[])
+{
+    printf(1,"COW demonstration:\n\n");
+    cow_demo();
+    exit();
+
+}
\ No newline at end of file
diff --git a/defs.h b/defs.h
index 34ed633..cbfd42e 100644
--- a/defs.h
+++ b/defs.h
@@ -115,7 +115,9 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-
+int             forkcow(void);
+int             waitcow(void);
+void			procdump(void);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
@@ -174,6 +176,13 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+// COW
+void            freeuvmcow(pde_t*);
+pde_t*          cowmapuvm(pde_t*, uint);
+int             copyuvmcow(void);
+
+
+
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/exec.c b/exec.c
index d56ee1d..2e268e6 100644
--- a/exec.c
+++ b/exec.c
@@ -17,7 +17,7 @@ exec(char *path, char **argv)
   struct inode *ip;
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
-
+  execSignalToThreads(thread);
   begin_op();
   if((ip = namei(path)) == 0){
     end_op();
@@ -94,8 +94,8 @@ exec(char *path, char **argv)
   oldpgdir = proc->pgdir;
   proc->pgdir = pgdir;
   proc->sz = sz;
-  proc->tf->eip = elf.entry;  // main
-  proc->tf->esp = sp;
+  thread->tf->eip = elf.entry;  // main
+  thread->tf->esp = sp;
   switchuvm(proc);
   freevm(oldpgdir);
   return 0;
diff --git a/fs.c b/fs.c
index 6887dbc..2b47908 100644
--- a/fs.c
+++ b/fs.c
@@ -166,10 +166,8 @@ iinit(int dev)
 {
   initlock(&icache.lock, "icache");
   readsb(dev, &sb);
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
-          inodestart %d bmap start %d\n", sb.size, sb.nblocks,
-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
-          sb.bmapstart);
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
+          sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
 }
 
 static struct inode* iget(uint dev, uint inum);
diff --git a/fssp.c b/fssp.c
new file mode 100644
index 0000000..e2a2cd4
--- /dev/null
+++ b/fssp.c
@@ -0,0 +1,413 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+//#include "uthread.h"
+
+#define Q 0
+#define P 1
+#define R 2
+#define Z 3
+#define M 4
+#define X 5
+#define F 6
+
+
+
+
+int table[5][6][6];
+int* arrayCurrent;
+int* arrayNext;
+int numberOfSoldiers;
+int endOfLine = 0; //to check if we done to calculate the whole line.
+//struct binary_semaphore print;
+//struct binary_semaphore calc;
+int print;
+int calc;
+
+struct idToSoldier{
+	int soldier;
+	int id;
+};
+
+typedef struct {
+	int pre_lock;
+	int post_lock;
+	int counter;
+	int max;
+} barrier;
+
+
+barrier b;
+static int mutex;
+struct idToSoldier *map;
+
+
+void initialTable(){
+	table[Q][Q][Q] = Q;
+	table[Q][P][Q] = P;
+	table[Q][R][Q] = Q;
+	table[Q][Z][Q] = Q;
+	table[Q][M][Q] = -1;
+	table[Q][X][Q] = Q;
+
+	table[Q][Q][P] = P;
+	table[Q][P][P] = P;
+	table[Q][R][P] = -1;
+	table[Q][Z][P] = -1;
+	table[Q][M][P] = -1;
+	table[Q][X][P] = P;
+
+	table[Q][Q][R] = Q;
+	table[Q][P][R] = -1;
+	table[Q][R][R] = Q;
+	table[Q][Z][R] = -1;
+	table[Q][M][R] = -1;
+	table[Q][X][R] = Q;
+
+	table[Q][Q][Z] = Q;
+	table[Q][P][Z] = -1;
+	table[Q][R][Z] = -1;
+	table[Q][Z][Z] = Q;
+	table[Q][M][Z] = -1;
+	table[Q][X][Z] = Q;
+
+	table[Q][Q][M] = -1;
+	table[Q][P][M] = -1;
+	table[Q][R][M] = -1;
+	table[Q][Z][M] = -1;
+	table[Q][M][M] = -1;
+	table[Q][X][M] = -1;
+
+	table[Q][Q][X] = Q;
+	table[Q][P][X] = P;
+	table[Q][R][X] = -1;
+	table[Q][Z][X] = Q;
+	table[Q][M][X] = -1;
+	table[Q][X][X] = -1;
+
+	//-------------------------------
+
+	table[Z][Q][Q] = -1;
+	table[Z][P][Q] = -1;
+	table[Z][R][Q] = Q;
+	table[Z][Z][Q] = P;
+	table[Z][M][Q] = Q;
+	table[Z][X][Q] = -1;
+
+	table[Z][Q][P] = -1;
+	table[Z][P][P] = Z;
+	table[Z][R][P] = -1;
+	table[Z][Z][P] = Z;
+	table[Z][M][P] = -1;
+	table[Z][X][P] = Z;
+
+	table[Z][Q][R] = Q;
+	table[Z][P][R] = -1;
+	table[Z][R][R] = Q;
+	table[Z][Z][R] = Q;
+	table[Z][M][R] = -1;
+	table[Z][X][R] = Q;
+
+	table[Z][Q][Z] = P;
+	table[Z][P][Z] = Z;
+	table[Z][R][Z] = Q;
+	table[Z][Z][Z] = F;
+	table[Z][M][Z] = Q;
+	table[Z][X][Z] = F;
+
+	table[Z][Q][M] = Q;
+	table[Z][P][M] = -1;
+	table[Z][R][M] = -1;
+	table[Z][Z][M] = Q;
+	table[Z][M][M] = Q;
+	table[Z][X][M] = Q;
+
+	table[Z][Q][X] = -1;
+	table[Z][P][X] = -1;
+	table[Z][R][X] = Q;
+	table[Z][Z][X] = F;
+	table[Z][M][X] = Q;
+	table[Z][X][X] = -1;
+
+	//-------------------------------
+
+	table[P][Q][Q] = Z;
+	table[P][P][Q] = Z;
+	table[P][R][Q] = R;
+	table[P][Z][Q] = R;
+	table[P][M][Q] = -1;
+	table[P][X][Q] = Z;
+
+	table[P][Q][P] = Z;
+	table[P][P][P] = -1;
+	table[P][R][P] = Z;
+	table[P][Z][P] = Z;
+	table[P][M][P] = -1;
+	table[P][X][P] = -1;
+
+	table[P][Q][R] = R;
+	table[P][P][R] = Z;
+	table[P][R][R] = Z;
+	table[P][Z][R] = -1;
+	table[P][M][R] = -1;
+	table[P][X][R] = Z;
+
+	table[P][Q][Z] = R;
+	table[P][P][Z] = Z;
+	table[P][R][Z] = -1;
+	table[P][Z][Z] = Z;
+	table[P][M][Z] = -1;
+	table[P][X][Z] = Z;
+
+	table[P][Q][M] = -1;
+	table[P][P][M] = -1;
+	table[P][R][M] = -1;
+	table[P][Z][M] = -1;
+	table[P][M][M] = -1;
+	table[P][X][M] = -1;
+
+	table[P][Q][X] = -1;
+	table[P][P][X] = -1;
+	table[P][R][X] = Z;
+	table[P][Z][X] = Z;
+	table[P][M][X] = -1;
+	table[P][X][X] = F;
+
+	//-------------------------------
+
+	table[M][Q][Q] = -1;
+	table[M][P][Q] = -1;
+	table[M][R][Q] = -1;
+	table[M][Z][Q] = -1;
+	table[M][M][Q] = -1;
+	table[M][X][Q] = -1;
+
+	table[M][Q][P] = -1;
+	table[M][P][P] = -1;
+	table[M][R][P] = -1;
+	table[M][Z][P] = -1;
+	table[M][M][P] = -1;
+	table[M][X][P] = -1;
+
+	table[M][Q][R] = -1;
+	table[M][P][R] = -1;
+	table[M][R][R] = R;
+	table[M][Z][R] = Z;
+	table[M][M][R] = -1;
+	table[M][X][R] = -1;
+
+	table[M][Q][Z] = -1;
+	table[M][P][Z] = -1;
+	table[M][R][Z] = Z;
+	table[M][Z][Z] = -1;
+	table[M][M][Z] = -1;
+	table[M][X][Z] = -1;
+
+	table[M][Q][M] = -1;
+	table[M][P][M] = -1;
+	table[M][R][M] = -1;
+	table[M][Z][M] = -1;
+	table[M][M][M] = -1;
+	table[M][X][M] = -1;
+
+	table[M][Q][X] = -1;
+	table[M][P][X] = -1;
+	table[M][R][X] = -1;
+	table[M][Z][X] = -1;
+	table[M][M][X] = -1;
+	table[M][X][X] = -1;
+
+	//-------------------------------
+
+	table[R][Q][Q] = -1;
+	table[R][P][Q] = -1;
+	table[R][R][Q] = R;
+	table[R][Z][Q] = P;
+	table[R][M][Q] = Z;
+	table[R][X][Q] = -1;
+
+	table[R][Q][P] = -1;
+	table[R][P][P] = -1;
+	table[R][R][P] = M;
+	table[R][Z][P] = R;
+	table[R][M][P] = M;
+	table[R][X][P] = -1;
+
+	table[R][Q][R] = R;
+	table[R][P][R] = M;
+	table[R][R][R] = -1;
+	table[R][Z][R] = -1;
+	table[R][M][R] = M;
+	table[R][X][R] = -1;
+
+	table[R][Q][Z] = P;
+	table[R][P][Z] = R;
+	table[R][R][Z] = -1;
+	table[R][Z][Z] = -1;
+	table[R][M][Z] = R;
+	table[R][X][Z] = -1;
+
+	table[R][Q][M] = Z;
+	table[R][P][M] = M;
+	table[R][R][M] = M;
+	table[R][Z][M] = R;
+	table[R][M][M] = M;
+	table[R][X][M] = -1;
+
+	table[R][Q][X] = -1;
+	table[R][P][X] = -1;
+	table[R][R][X] = -1;
+	table[R][Z][X] = -1;
+	table[R][M][X] = -1;
+	table[R][X][X] = -1;
+}
+void printSoldier(int i){
+	if(i==0) printf(1,"Q");
+	else if(i==1) printf(1,"P");
+	else if(i==2) printf(1,"R");
+	else if(i==3) printf(1,"Z");
+	else if(i==4) printf(1,"M");
+	else if(i==5) printf(1,"X");
+	else if(i==6) printf(1,"F");
+
+
+}
+void print_all(){
+	int i;
+	for(i = 0; i < numberOfSoldiers; i++){
+		//printf(1,"loop\n");
+		printSoldier(arrayCurrent[i]);
+
+	}
+	printf(1,"\n");
+}
+int getSoldierFromId(int id){
+	int i;
+	for(i=0;i<numberOfSoldiers;i++){
+		if(map[i].id==id)
+			return map[i].soldier;
+	}
+	return -1;
+}
+
+void free_barrier(barrier *b){
+	kthread_mutex_dealloc(b->pre_lock);
+	kthread_mutex_dealloc(b->post_lock);
+	b->max = 0;
+	b->counter = 0;
+}
+
+void init_barrier(barrier *b, int max){
+	b->pre_lock = kthread_mutex_alloc();
+	b->post_lock = kthread_mutex_alloc();
+	b->max = max;
+	b->counter = 0;
+	kthread_mutex_lock(b->post_lock);	
+}
+
+void barrier_increase(barrier* b){
+	kthread_mutex_lock(b->pre_lock);
+	b->counter++;
+	if(b->max > b->counter)
+		kthread_mutex_unlock(b->pre_lock);	
+	else // max == counter
+		kthread_mutex_unlock(b->post_lock);			
+	
+	kthread_mutex_lock(b->post_lock);
+	b->counter--;
+	if(b->counter > 0)
+		kthread_mutex_unlock(b->post_lock);
+	else // counter == 0
+		kthread_mutex_unlock(b->pre_lock);
+}
+
+void updateState(){
+	barrier_increase(&b);
+	int i=getSoldierFromId(kthread_id());
+	int next=0;
+	while(arrayCurrent[i] != F){
+		
+		if(i == 0){
+			next = table[arrayCurrent[i]][X][arrayCurrent[i+1]];
+		}
+		else if (i > 0 && i < numberOfSoldiers-1){
+			next = table[arrayCurrent[i]][arrayCurrent[i-1]][arrayCurrent[i+1]];
+		}
+		else if (i == numberOfSoldiers-1){
+			next = table[arrayCurrent[i]][arrayCurrent[i-1]][X];
+		}
+		barrier_increase(&b);	// wait for all thread to calculate their next_state
+		arrayNext[i]=next;
+		arrayCurrent=arrayNext;
+		barrier_increase(&b);
+		if(i==0){
+			kthread_mutex_lock(mutex);
+			
+			print_all();
+			kthread_mutex_unlock(mutex);
+		}
+		
+	}
+
+	kthread_exit();
+}
+
+
+int main(int argc, char **argv)
+{
+	if(argc != 2){
+		printf(1,"Missing arguments. cannot init without number of sodliers\n");
+		exit();
+	}
+	numberOfSoldiers = atoi(argv[1]);
+	if(numberOfSoldiers > 15){ //15=16-1 = MAXTHREADS-MAIN
+		printf(1,"There is too many soldiers. cannot support more threads .\n ");
+		exit();
+	}
+
+	if(numberOfSoldiers <= 1){
+		printf(1,"The number of soldier must be positive.\n");
+		exit();
+	}
+	int i;
+	struct idToSoldier map1[numberOfSoldiers];
+	map= map1;
+	mutex = kthread_mutex_alloc();
+	init_barrier(&b,numberOfSoldiers);
+	arrayCurrent = (int*)malloc(numberOfSoldiers * sizeof(int)); //current state
+	arrayNext = (int*)malloc(numberOfSoldiers * sizeof(int)); //next state
+	initialTable();
+	//uthread_init();
+	arrayCurrent[0] = P;
+
+
+	for(i = 1; i < numberOfSoldiers; i++){
+		arrayCurrent[i] = Q;
+		
+	}
+	
+	for(i =0; i < numberOfSoldiers; i++){
+		void* stack = malloc (1024);
+		int id=kthread_create((void*) updateState, stack,1024);
+		map[i].id=id;
+		map[i].soldier=i;
+
+	}
+	print_all();
+
+	for(i=0;i<numberOfSoldiers;i++){
+		kthread_join(map[i].id);
+	}
+
+	kthread_mutex_dealloc(mutex);
+	free_barrier(&b);
+
+
+
+	exit();
+
+	return 0;
+}
+
+
+
diff --git a/htest.c b/htest.c
new file mode 100644
index 0000000..6ade7aa
--- /dev/null
+++ b/htest.c
@@ -0,0 +1,150 @@
+/*
+ * htest.c
+ *
+ *  Created on: Apr 26, 2015
+ *      Author: hodai
+ */
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+
+#define STACK_SIZE 1000
+
+void* execThread(){
+  char* cat[] ={"cat", 0};
+  printf(1, "exec thread, tid:%d\n", kthread_id());
+  exec("cat", cat);
+  printf(2, "error - return from exec\n");
+  exit();
+}
+
+void* exitThread(){
+  printf(1, "exit thread, tid:%d\n", kthread_id());
+  exit();
+}
+void* normalThread(){
+  printf(1, "normal thread, tid:%d\n", kthread_id());
+  kthread_exit();
+  return 0;
+}
+
+void* loopThread(){
+  printf(1, "loop thread, tid:%d\n", kthread_id());
+  for(;;){};
+  kthread_exit();
+  return 0;
+}
+
+void* sleepThread(){
+  printf(1, "sleep thread, tid:%d\n", kthread_id());
+  sleep(1000);
+  printf(1, "tid:%d done\n", kthread_id());
+  kthread_exit();
+  return 0;
+}
+
+void* theThread(){
+  int i;
+  for(i = 0 ;i < 10; i++){
+    printf(1, "thread:%d,i=%d\n", kthread_id(), i);
+  }
+  kthread_exit();
+  return 0;
+}
+
+void stressTest1(int count){
+  int tid[count];
+  int i,ans;
+  char* stack;
+  int fail = 0;
+
+  for (i = 0 ; i < count; i++){
+    stack = malloc(STACK_SIZE);
+    tid[i] = kthread_create(theThread, stack+STACK_SIZE, STACK_SIZE);
+    if(tid[i] <= 0){
+      printf(2, "error: kthread_create return with: %d, for index:%d", tid[i], i);
+      fail = 1;
+    }
+  }
+
+  for (i = 0 ; i < count; i++){
+    ans = kthread_join(tid[i]);
+    if(ans != 0){
+      printf(2, "error: kthread_join(%d) return with: %d", tid[i], ans);
+      fail = 1;
+    }
+  }
+
+  if(fail){
+    printf(1, "stressTest1 fail\n");
+  } else {
+    printf(1, "stressTest1 success\n");
+  }
+
+}
+
+int main(){
+  char buf[100];
+  void* stack;
+  int t;
+  printf(1, "chose operation\n");
+  stack = malloc(STACK_SIZE);
+
+  while(read(0, buf, 100) >= 0){
+    stack = malloc(STACK_SIZE);
+    if(strcmp("sleep\n", buf) == 0){
+      t = kthread_create(sleepThread, stack+STACK_SIZE, STACK_SIZE);
+      printf(1, "creating sleep thread tid:%d\n", t);
+
+    } else if(strcmp(buf, "loop\n") == 0){
+      t = kthread_create(loopThread, stack+STACK_SIZE, STACK_SIZE);
+      printf(1, "creating loop thread tid:%d\n", t);
+
+    } else if(strcmp(buf, "norm\n") == 0){
+      t = kthread_create(normalThread, stack+STACK_SIZE, STACK_SIZE);
+      printf(1, "creating normal thread tid:%d\n", t);
+
+    } else if(strcmp(buf, "join\n") == 0){
+      printf(1,"chose tid: ");
+      if(read(0, buf, 100) > 0){
+        t = atoi(buf);
+        printf(1, "joining thread tid:%d\n", t);
+        t = kthread_join(t);
+        printf(1, "join result:%d \n", t);
+      } else{
+        printf(2,"fail\n");
+      }
+
+    } else if(strcmp(buf, "et\n") == 0){
+      t = kthread_create(exitThread, stack+STACK_SIZE, STACK_SIZE);
+      printf(1, "creating exit thread tid:%d\n", t);
+
+    } else if(strcmp(buf, "exec\n") == 0){
+      t = kthread_create(execThread, stack+STACK_SIZE, STACK_SIZE);
+      printf(1, "creating exec thread tid:%d\n", t);
+
+    } else if(strcmp(buf, "exit\n") == 0){
+      printf(1, "exiting program\n");
+      exit();
+
+    } else if(strcmp(buf, "stress\n") == 0){
+      printf(1,"chose num of threads: ");
+      if(read(0, buf, 100) > 0){
+        t = atoi(buf);
+        stressTest1(t);
+      } else{
+        printf(2,"fail\n");
+      }
+    } else {
+      printf(2, "error: %s\n", buf);
+    }
+
+    memset(buf, 0, 100);
+  }
+
+  exit();
+}
+
diff --git a/kthread.c b/kthread.c
new file mode 100644
index 0000000..53e0cdd
--- /dev/null
+++ b/kthread.c
@@ -0,0 +1,107 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "spinlock.h"
+#include "proc.h"
+#include "kthread.h"
+extern void forkret(void);
+
+
+void wakeupThreads(void* chan){
+	struct thread* t;
+	for(t=proc->threads;t<&proc->threads[NTHREAD];t++){
+		if(t->state==SLEEPING&&t->chan==chan){
+			t->state=RUNNABLE;
+		}
+	}
+}
+
+int last(struct thread* t){
+	struct proc* p =t->process;
+	struct thread* temp;
+	int i=0;
+	for(temp=p->threads;temp<&p->threads[NTHREAD];t++){
+		i++;
+		if(temp!=t&&temp->state!=ZOMBIE&&temp->state!=UNUSED){
+			
+			cprintf("its ids %s, %d, %d, i:%d",t->process->name,t->id,temp->id,i);
+			return 0;
+		}
+	}
+	return 1;
+		
+	
+}
+
+int kthread_create(void* (start_func)(),void* stack,int stack_size){
+	struct thread* new;
+	new =allocthread(proc);
+	if(!new||stack<=0)
+		return -1;
+	//cprintf("the func pointer is %x\n",start_func);
+	*new->tf=*thread->tf;
+	//new->tf->eflags = FL_IF;
+	new->tf->eip=(uint)start_func;
+	new->tf->esp=(uint) (stack+stack_size);
+
+	//new->context->eip=(int)start_func;
+	//new->context->eip = (uint)forkret;
+	//new->context->esp=(int) (stack)+stack_size;
+
+	new->state=RUNNABLE;
+
+	return new->id;
+}
+
+int kthread_id(){
+	return thread->id;
+}
+
+
+
+int kthread_join(int thread_id){
+	struct thread* t;
+	int exists=0;
+	
+	acquire(&proc->lock);
+	
+	for(t = proc->threads; t < &proc->threads[NTHREAD]; t++){
+		if(t->id==thread_id){
+			exists=1;
+			break;
+		}
+	}
+	if(!exists){
+		release(&proc->lock);
+		return -1;
+	}
+	if(t->state==UNUSED){
+  	release(&proc->lock);
+  	return 0;
+  }
+	else if(t->state == ZOMBIE){
+		free_and_return:
+    kfree(t->kstack);
+    t->kstack = 0;
+    t->state = UNUSED;
+    release(&proc->lock);
+    return 0;
+  }
+  else{
+  	while(t->state!=ZOMBIE){
+  		sleep(t,&proc->lock);
+  		}
+  	if(t->state==UNUSED)
+  		panic("kthread_join: won't wake up because thread was going from ready to unused");
+  	goto free_and_return;
+  }
+   
+ 
+
+    return 0;
+}
+
+
diff --git a/kthread.h b/kthread.h
new file mode 100644
index 0000000..a1a1ca4
--- /dev/null
+++ b/kthread.h
@@ -0,0 +1,36 @@
+#ifndef KTHREAD_H
+#define KTHREAD_H
+
+#define NTHREAD 16
+#define MAX_MUTEXES 64
+
+
+int kthread_create(void* (start_func)(),void* stack,int stack_size);
+int kthread_id();
+void kthread_exit();
+int kthread_join();
+int kthread_mutex_alloc();
+int kthread_mutex_dealloc(int mutex_id);
+int kthread_mutex_lock(int mutex_id);
+int kthread_mutex_unlock(int mutex_id);
+int kthread_mutex_num(int mutex_id);
+
+
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+
+struct thread{
+  int id;
+  char *kstack;                // Bottom of kernel stack for this Thread
+  enum procstate state;        // Thread state
+  struct proc* process;         // Parent process
+  struct trapframe *tf;        // Trap frame for current syscall
+  struct context *context;     // swtch() here to run process
+  void *chan;                  // If non-zero, sleeping on chan
+  int killed;
+  struct thread* list;
+};
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/mt.c b/mt.c
new file mode 100644
index 0000000..60657af
--- /dev/null
+++ b/mt.c
@@ -0,0 +1,259 @@
+/*
+ * mutextest.c
+ *
+ *  Created on: Apr 26, 2015
+ *      Author: hodai
+ */
+
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define STACK_SIZE 1000
+
+/* globals */
+int mutex1;
+int mutex2;
+int resource1[20];
+int resource2;
+
+/* utils */
+//#define STACK_PLUS_AT_KERNEL    //define at makefile
+#ifdef STACK_PLUS_AT_KERNEL
+  #define STACK(start, size) (stack)
+#else
+  #define STACK(start, size) (stack + size)
+#endif
+
+
+#define ASSERT(cond, ...) \
+    if(cond){ \
+      printf(2, "FAIL at %s:%d - ", __FUNCTION__, __LINE__); \
+      printf(2, __VA_ARGS__); \
+      printf(2, "\n"); \
+      exit(); \
+    }
+
+
+void* safeThread(){
+  int i;
+
+  /* part one use mutual array of resources */
+  ASSERT((kthread_mutex_lock(mutex1) == -1), "kthread_mutex_lock(%d) fail", mutex1);
+
+  resource1[0] = kthread_id();
+  for(i = 1 ;i < 20; i++){
+    sleep(i % 2);   // make some more troubles
+    resource1[i] = resource1[i-1];
+  }
+  sleep(kthread_id() % 2);   // make some more troubles
+  ASSERT((resource1[i-1] != kthread_id()), "(resource1[%d] != kthread_id:%d) fail", i, kthread_id());
+
+  ASSERT((kthread_mutex_unlock(mutex1) == -1), "kthread_mutex_unlock(%d) fail", mutex1);
+
+  /* part two - mutual calculation */
+  ASSERT((kthread_mutex_lock(mutex2) == -1), "kthread_mutex_lock(%d) fail", mutex2);
+  sleep(kthread_id() % 2);   // make some more troubles
+  resource2 = resource2 + kthread_id();
+  ASSERT((kthread_mutex_unlock(mutex2) == -1), "kthread_mutex_unlock(%d) fail", mutex2);
+
+  kthread_exit();
+  return 0;
+}
+
+void* unsafeThread(){
+  int i;
+
+  resource1[0] = kthread_id();
+  for(i = 1 ;i < 20; i++){
+    sleep(i % 2);   // make some more troubles
+    resource1[i] = resource1[i-1];
+  }
+  sleep(kthread_id());   // make some more troubles
+  //ASSERT((resource1[i-1] != kthread_id()), "(resource1[%d] != kthread_id()) fail", i);
+
+  resource2 = resource2 + resource1[i-1];
+
+  kthread_exit();
+  return 0;
+}
+
+void* loopThread(){
+  for(;;){};
+  return 0;
+}
+
+void stressTest1(int count){
+  int tid[count];
+  int i,ans;
+  int c=0;
+  char* stack;
+
+  printf(1, "starting %s test\n", __FUNCTION__);
+
+  for (i = 0 ; i < 20; i++)
+    resource1[i] = 0;
+  resource2 = 0;
+  mutex1 = kthread_mutex_alloc();
+
+  mutex2 = kthread_mutex_alloc();
+
+  ASSERT((mutex1 == mutex2), "(mutex1 == mutex2)");
+
+  for (i = 0 ; i < count; i++){
+    stack = malloc(STACK_SIZE);
+    tid[i] = kthread_create((void*) safeThread, stack, STACK_SIZE);
+    ASSERT((tid[i] <= 0), "kthread_create return with: %d, for index:%d", tid[i], i);
+    c += tid[i];
+    sleep(i % 2);   // make some more troubles
+  }
+  for (i = 0 ; i < count; i++){
+
+    ans = kthread_join(tid[i]);
+    // if fail here it's not always error!
+    ASSERT((ans != 0), "kthread_join(%d) return with: %d", tid[i], ans)
+  }
+
+  // free the mutexes
+  ASSERT( (kthread_mutex_dealloc(mutex1) != 0), "dealloc");
+  ASSERT( (kthread_mutex_dealloc(mutex2) != 0), "dealloc");
+
+  ASSERT((c != resource2), "(c != resource2) : (%d != %d)" , c, resource2);
+
+  printf(1, "%s test PASS!\n", __FUNCTION__);
+
+}
+
+/* this test should fail most of the time because synchronization error */
+void stressTest2Fail(int count){
+  int tid[count];
+  int i,ans;
+  int c=0;
+  char* stack;
+
+  printf(1, "starting %s test\n", __FUNCTION__);
+
+  for (i = 0 ; i < 20; i++)
+    resource1[i] = 0;
+  resource2 = 0;
+
+  for (i = 0 ; i < count; i++){
+    stack = malloc(STACK_SIZE);
+    tid[i] = kthread_create(&unsafeThread, stack, STACK_SIZE);
+    sleep(i %3);   // make some more troubles
+    ASSERT((tid[i] <= 0), "kthread_create return with: %d, for index:%d", tid[i], i);
+    c += tid[i];
+  }
+
+  for (i = 0 ; i < count; i++){
+    ans = kthread_join(tid[i]);
+    // if fail here it's not always error!
+    ASSERT((ans != 0), "kthread_join(%d) return with: %d", tid[i], ans)
+  }
+
+  ASSERT((c == resource2), "(c == resource2) : (%d != %d), we expect to fail here!!" , c, resource2);
+
+  printf(1, "%s test PASS!\n", __FUNCTION__);
+
+}
+
+/* this test check that we can't create more then 16(count) threads  */
+void stressTest3toMuchTreads(int count){
+  int tid[count*2];
+  int i;
+  char* stack;
+
+  printf(1, "starting %s test\n", __FUNCTION__);
+
+  for (i = 0 ; i < count; i++){
+    stack = malloc(STACK_SIZE);
+    tid[i] = kthread_create(&loopThread, stack, STACK_SIZE);
+    ASSERT((tid[i] <= 0), "kthread_create return with: %d, for index:%d", tid[i], i);
+  
+
+  if(kthread_create(&loopThread, stack, STACK_SIZE) <= 0)
+  {
+    printf(1, "%s test FAIL!\n", __FUNCTION__);
+  } 
+  else 
+  {
+    printf(1, "%s test PASS!\n", __FUNCTION__);
+  }
+}
+  // the threads do not kill themself
+  exit();
+
+}
+
+
+
+void* trubleThread(){
+
+  ASSERT((kthread_mutex_lock(mutex1) == -1), "kthread_mutex_lock(%d) fail", mutex1);
+  resource2 = -10;
+
+  ASSERT((kthread_mutex_unlock(mutex1) == -1), "kthread_mutex_unlock(%d) fail", mutex1);
+
+  kthread_exit();
+  return 0;
+}
+
+
+
+void senaty(int count){
+  int i, j;
+  int mutex[64];
+
+  printf(1, "starting %s test\n", __FUNCTION__);
+  for(j=0 ; j<2 ; j++){ // run the test twice to check that mutexes can be reused
+    for(i=0 ; i < count ; i++){
+      mutex[i] = kthread_mutex_alloc();
+      ASSERT((mutex[i] == -1), "kthread_mutex_alloc fail, i=%d", i);
+      ASSERT((kthread_mutex_lock(mutex[i]) == -1), "kthread_mutex_lock(%d) fail", mutex[i]);
+      ASSERT((kthread_mutex_unlock(mutex[i]) == -1), "kthread_mutex_unlock(%d) fail", mutex[i]);
+      ASSERT((kthread_mutex_unlock(mutex[i]) != -1), "second kthread_mutex_unlock(%d) didn't fail as expected", mutex[i]);
+    }
+
+    for(i=0 ; i < count ; i++){
+      ASSERT((kthread_mutex_lock(mutex[i]) == -1), "kthread_mutex_lock(%d) fail", mutex[i]);
+    }
+
+    for(i=0 ; i < count ; i++){
+      ASSERT((kthread_mutex_unlock(mutex[i]) == -1), "kthread_mutex_unlock(%d) fail", mutex[i]);
+      ASSERT((kthread_mutex_unlock(mutex[i]) != -1), "second kthread_mutex_unlock(%d) didn't fail as expected", mutex[i]);
+    }
+
+    for(i=0 ; i < count ; i++){
+      ASSERT((kthread_mutex_dealloc(mutex[i]) == -1), "kthread_mutex_dealloc(%d) fail", mutex[i]);
+      ASSERT((kthread_mutex_dealloc(mutex[i]) != -1), "second kthread_mutex_dealloc(%d) didn't fail as expected", mutex[i]);
+      ASSERT((kthread_mutex_lock(mutex[i]) != -1), "kthread_mutex_lock(%d) didn't fail after dealloc", mutex[i]);
+      ASSERT((kthread_mutex_unlock(mutex[i]) != -1), "kthread_mutex_unlock(%d) didn't fail after dealloc", mutex[i]);
+    }
+  }
+
+  /* chack that mutexes are really limited by 64 */
+  for (i=0 ; i<64 ; i++){
+    mutex[i] = kthread_mutex_alloc();
+    ASSERT((mutex[i] == -1), "kthread_mutex_alloc (limit) fail, i=%d, expected fail at:%d", i, 64);
+  }
+
+  ASSERT((kthread_mutex_alloc() != -1), "limit test didn't fail as expected create %d mutexes instad of %d", i+1, 64);
+
+  // release all mutexes
+  for (i=0 ; i<64 ; i++){
+    ASSERT((kthread_mutex_dealloc(mutex[i]) == -1), "kthread_mutex_dealloc(%d) fail, i=%d", mutex[i], i);
+  }
+
+  printf(1, "%s test PASS!\n", __FUNCTION__);
+}
+
+int main(){
+  senaty(64);
+  stressTest1(15);
+  stressTest2Fail(15);
+  stressTest3toMuchTreads(15); //this test must be the last
+
+  exit();
+}
+
diff --git a/mtest.c b/mtest.c
new file mode 100644
index 0000000..f0577b7
--- /dev/null
+++ b/mtest.c
@@ -0,0 +1,57 @@
+/*
+ * author : Erez Fremder
+ */
+
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int mutex;
+int test;
+
+void printer (){
+	int input;
+	input = kthread_mutex_lock(mutex);
+	if(input<0)
+		printf(1,"Error: thread mutex didnt lock!");
+	printf(1,"thread %d said hi\n",kthread_id());
+	test=1;
+	input = kthread_mutex_unlock(mutex);
+	if(input<0)
+		printf(1,"Error: thread mutex didnt unlock!");
+	kthread_exit();
+	printf(1,"Error: returned from exit !!");
+}
+
+int main(int argc, char **argv)
+{
+	printf(1,"~~~~~~~~~~~~~~~~~~\ntest starts\nIf it ends without Errors you win! : )\n~~~~~~~~~~~~~~~~~~\n");
+	int input,i;
+	mutex = kthread_mutex_alloc();
+	printf(1,"the mutex: %d\n",mutex);
+	if(mutex<0)
+		printf(1,"Error: mutex didnt alloc! (%d)\n",mutex);
+	for(i = 0; i<5; i++){
+		test=0;
+		input = kthread_mutex_lock(mutex);
+		if(input<0)
+			printf(1,"Error: mutex didnt lock! (%d)\n",input);
+		char * stack = malloc (1024);
+		int tid = kthread_create ((void*)printer, stack, 1024);
+		if(tid<0) printf(1,"Thread wasnt created correctly! (%d)\n",tid);
+		printf(1,"joining on thread %d\n",tid);
+		if(test)printf(1,"Error: mutex didnt prevent writing!\n");
+		input = kthread_mutex_unlock(mutex);
+		if(input<0) printf(1,"Error: mutex didnt unlock!\n");
+		kthread_join(tid);
+		if(!test) printf(1,"Error: thread didnt run!\n");
+		printf(1,"finished join\n");
+	}
+	printf(1,"Exiting\n");
+	input = kthread_mutex_dealloc(mutex);
+	if(input<0)
+		printf(1,"Error: mutex didnt dealloc!\n");
+	exit();
+	printf(1,"Error: returned from exit !!\n");
+}
diff --git a/pipe.c b/pipe.c
index f76ed5c..067bed9 100644
--- a/pipe.c
+++ b/pipe.c
@@ -82,7 +82,7 @@ pipewrite(struct pipe *p, char *addr, int n)
   acquire(&p->lock);
   for(i = 0; i < n; i++){
     while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-      if(p->readopen == 0 || proc->killed){
+      if(p->readopen == 0 || proc->killed||proc->executed){
         release(&p->lock);
         return -1;
       }
@@ -103,7 +103,7 @@ piperead(struct pipe *p, char *addr, int n)
 
   acquire(&p->lock);
   while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-    if(proc->killed){
+    if(proc->killed||proc->executed){
       release(&p->lock);
       return -1;
     }
diff --git a/proc.c b/proc.c
index eee79af..6b6abee 100644
--- a/proc.c
+++ b/proc.c
@@ -4,70 +4,154 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "x86.h"
-#include "proc.h"
 #include "spinlock.h"
+#include "proc.h"
+#include "kthread.h"
 
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
 
+struct{
+  struct spinlock lock;
+  struct kthread_mutex_t mutexes[MAX_MUTEXES];
+}mtable;
+
 static struct proc *initproc;
 
 int nextpid = 1;
+int nextThread=1 ;
 extern void forkret(void);
 extern void trapret(void);
-
+extern void wakeupThreads(struct thread* t);
+extern int last(struct thread* t);
 static void wakeup1(void *chan);
 
 void
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  initlock(&mtable.lock,"mtable");
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-// Must hold ptable.lock.
-static struct proc*
-allocproc(void)
+struct thread* allocthread (struct proc* p)
 {
-  struct proc *p;
-  char *sp;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  struct thread* t;
+  char *sp;
+  acquire(&ptable.lock);
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+    if(t->state == UNUSED)
       goto found;
+  }
+  release(&ptable.lock);
   return 0;
 
 found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
 
+  t->state = EMBRYO;
+  t->id = nextThread++;    // must hold the lock to avoid duplicate id's
+  t->list=0;
+  release(&ptable.lock);
+  t->process = p;
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
-    p->state = UNUSED;
+  if((t->kstack = kalloc()) == 0){
+    t->state = UNUSED;
     return 0;
   }
-  sp = p->kstack + KSTACKSIZE;
+  sp = t->kstack + KSTACKSIZE;
 
   // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  sp -= sizeof *t->tf;
+  t->tf = (struct trapframe*)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
   *(uint*)sp = (uint)trapret;
 
-  sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
+  sp -= sizeof *t->context;
+  t->context = (struct context*)sp;
+  memset(t->context, 0, sizeof *t->context);
+  t->context->eip = (uint)forkret;
+
+  return t;
+}
+void execSignalToThreads(struct thread* t){
+  struct thread* temp;
+  int allDone;
+  acquire(&t->process->lock);
+  //t->process->executed=1;
+  while(1){
+    if(proc->killed){
+      release(&t->process->lock);
+      exit();
+    }
+    allDone=1;
+    for(temp=t->process->threads;temp<&t->process->threads[NTHREAD];temp++){
+      //unrelevent threads.no point waiting on them
+        if(temp==t||temp->state==UNUSED)
+          continue;
+
+        if(temp->state==ZOMBIE){
+          //thread was terminated
+          temp->state=UNUSED;
+          kfree(temp->kstack);
+          temp->kstack=0;
+          continue;
+        }
+
+        if(temp->state==SLEEPING){
+          //wakeup in order for it to terminate;
+          //temp->killed=1;
+          temp->state=RUNNABLE;
+          }
+          temp->killed=1;
+          release(&t->process->lock);
+          kthread_join(temp->id);
+          acquire(&t->process->lock);
+        allDone=0;
+      }
+      if(allDone){
+        t->process->executed=0;
+        release(&t->process->lock);
+        return;
+      }
+      //sleep(t->process,&t->process->lock); //go to sleep until the next one is done;
+
+  }
+}
+
+//PAGEBREAK: 32
+// Look in the process table for an UNUSED proc.
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+// Must hold ptable.lock.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  struct thread* t;
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+  return 0;
 
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+  p->shared=0;
+  initlock(&p->lock,"proclock");
+  for (t = p->threads ; t < &p->threads[NTHREAD] ; t++)
+    t->state = UNUSED;
+  
+  
+  release(&ptable.lock);
+  t = allocthread(p);
   return p;
 }
 
@@ -78,42 +162,30 @@ userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  acquire(&ptable.lock);
-
   p = allocproc();
-
-  // release the lock in case namei() sleeps.
-  // the lock isn't needed because no other
-  // thread will look at an EMBRYO proc.
-  release(&ptable.lock);
-  
   initproc = p;
+ 
   if((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
 
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
 
-  p->state = RUNNABLE;
+  struct thread* t;
+  t=p->threads;
+  memset(t->tf, 0, sizeof(*t->tf));
+  t->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  t->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  t->tf->es = t->tf->ds;
+  t->tf->ss = t->tf->ds;
+  t->tf->eflags = FL_IF;
+  t->tf->esp = PGSIZE;
+  t->tf->eip = 0;  // beginning of initcode.S
 
-  release(&ptable.lock);
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+  p->state=RUNNABLE;
+  t->state = RUNNABLE;
 }
 
 // Grow current process's memory by n bytes.
@@ -145,30 +217,72 @@ fork(void)
   int i, pid;
   struct proc *np;
 
-  acquire(&ptable.lock);
-
   // Allocate process.
-  if((np = allocproc()) == 0){
-    release(&ptable.lock);
+  if((np = allocproc()) == 0)
+    return -1;
+  struct thread* t = np->threads;
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(t->kstack); 
+    t->kstack = 0;
+    np->state = UNUSED;
+    t->state = UNUSED;
     return -1;
   }
+  np->sz = proc->sz;
+  np->parent = proc;
+  *t->tf = *thread->tf;           
+
+  // Clear %eax so that fork returns 0 in the child.
+  t->tf->eax = 0;                 
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
 
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+ 
+  pid = np->pid;
+
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  t->state = RUNNABLE;  
+  np->state = RUNNABLE;             // the proc is in state: Runnable, running or sleeping
   release(&ptable.lock);
+  
+  return pid;
+}
+
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+forkcow(void)
+{
+  int i, pid;
+  struct proc *np;
 
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+  struct thread* t = np->threads;
   // Copy process state from p.
-  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
-    kfree(np->kstack);
-    np->kstack = 0;
+  if((np->pgdir = cowmapuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(t->kstack); 
+    t->kstack = 0;
     np->state = UNUSED;
-    release(&ptable.lock);
+    t->state = UNUSED;
     return -1;
   }
   np->sz = proc->sz;
   np->parent = proc;
-  *np->tf = *proc->tf;
+  proc->shared=1;
+  np->shared=1;
+  *t->tf = *thread->tf;           
 
   // Clear %eax so that fork returns 0 in the child.
-  np->tf->eax = 0;
+  t->tf->eax = 0;                 
 
   for(i = 0; i < NOFILE; i++)
     if(proc->ofile[i])
@@ -176,25 +290,28 @@ fork(void)
   np->cwd = idup(proc->cwd);
 
   safestrcpy(np->name, proc->name, sizeof(proc->name));
-
+ 
   pid = np->pid;
 
+  // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
-
-  np->state = RUNNABLE;
-
+  t->state = RUNNABLE;  
+  np->state = RUNNABLE;             // the proc is in state: Runnable, running or sleeping
   release(&ptable.lock);
-
+  
   return pid;
 }
 
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
 exit(void)
 {
+
   struct proc *p;
+  struct thread* t;
   int fd;
 
   if(proc == initproc)
@@ -214,12 +331,13 @@ exit(void)
   proc->cwd = 0;
 
   acquire(&ptable.lock);
-
+  wakeup1(thread);
   // Parent might be sleeping in wait().
   wakeup1(proc->parent);
 
   // Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+
     if(p->parent == proc){
       p->parent = initproc;
       if(p->state == ZOMBIE)
@@ -227,8 +345,17 @@ exit(void)
     }
   }
 
+  for(t=proc->threads;t<&proc->threads[NTHREAD];t++){
+      t->id=0;
+      if(t->state!=UNUSED)
+        t->state=ZOMBIE;
+      t->chan=0;
+      t->process=0;
+    }
+
   // Jump into the scheduler, never to return.
   proc->state = ZOMBIE;
+  thread->state=ZOMBIE;
   sched();
   panic("zombie exit");
 }
@@ -238,12 +365,13 @@ exit(void)
 int
 wait(void)
 {
+
   struct proc *p;
   int havekids, pid;
-
+  struct thread* t;
   acquire(&ptable.lock);
   for(;;){
-    // Scan through table looking for exited children.
+    // Scan through table looking for zombie children.
     havekids = 0;
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->parent != proc)
@@ -252,13 +380,84 @@ wait(void)
       if(p->state == ZOMBIE){
         // Found one.
         pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
+       
+        for(t = p->threads ; t < &p->threads[NTHREAD] ; t++){
+          if(t->state != UNUSED){
+            if(t->state != ZOMBIE)
+              panic("wait panic: not ZOMBIE or UNUSED");
+            
+            kfree(t->kstack);
+            t->kstack = 0;
+            t->state = UNUSED;
+          }
+        }
         freevm(p->pgdir);
         p->pid = 0;
+        p->executed=0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+
+        p->state = UNUSED;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed|| proc->executed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+waitcow(void)
+{
+
+  struct proc *p;
+  int havekids, pid;
+  struct thread* t;
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+       
+        for(t = p->threads ; t < &p->threads[NTHREAD] ; t++){
+          if(t->state != UNUSED){
+            if(t->state != ZOMBIE)
+              panic("wait panic: not ZOMBIE or UNUSED");
+            
+            kfree(t->kstack);
+            t->kstack = 0;
+            t->state = UNUSED;
+          }
+        }
+        if(!p->shared)
+          freevm(p->pgdir);
+        else{
+          freeuvmcow(p->pgdir);
+          p->shared=0;
+        }
+
+        p->pid = 0;
+        p->executed=0;
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
+
         p->state = UNUSED;
         release(&ptable.lock);
         return pid;
@@ -266,7 +465,7 @@ wait(void)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || proc->killed){
+    if(!havekids || proc->killed|| proc->executed){
       release(&ptable.lock);
       return -1;
     }
@@ -284,11 +483,12 @@ wait(void)
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
+
 void
 scheduler(void)
 {
   struct proc *p;
-
+  struct thread* t;
   for(;;){
     // Enable interrupts on this processor.
     sti();
@@ -296,27 +496,40 @@ scheduler(void)
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+      if (p->state != RUNNABLE)
         continue;
 
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-      swtch(&cpu->scheduler, p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      proc = 0;
+      for(t = p->threads; t < &p->threads[NTHREAD]; t++){
+        if(t->state != RUNNABLE)
+          continue;
+
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        proc = p;
+        thread = t;
+        //cprintf("chosen tid:%d\n",t->id);
+       
+       // if(t->id==4)
+         // cprintf("4\n");
+        switchuvm(p);
+
+        t->state = RUNNING;
+        swtch(&cpu->scheduler, t->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        proc = 0;
+        thread = 0;
+      }
     }
     release(&ptable.lock);
 
   }
 }
 
+
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
@@ -338,7 +551,7 @@ sched(void)
   if(readeflags()&FL_IF)
     panic("sched interruptible");
   intena = cpu->intena;
-  swtch(&proc->context, cpu->scheduler);
+  swtch(&thread->context, cpu->scheduler);
   cpu->intena = intena;
 }
 
@@ -347,7 +560,8 @@ void
 yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
-  proc->state = RUNNABLE;
+  thread->state = RUNNABLE;
+
   sched();
   release(&ptable.lock);
 }
@@ -396,12 +610,12 @@ sleep(void *chan, struct spinlock *lk)
   }
 
   // Go to sleep.
-  proc->chan = chan;
-  proc->state = SLEEPING;
+  thread->chan = chan;
+  thread->state = SLEEPING;
   sched();
 
   // Tidy up.
-  proc->chan = 0;
+  thread->chan = 0;
 
   // Reacquire original lock.
   if(lk != &ptable.lock){  //DOC: sleeplock2
@@ -411,16 +625,17 @@ sleep(void *chan, struct spinlock *lk)
 }
 
 //PAGEBREAK!
-// Wake up all processes sleeping on chan.
+// Wake up all processes and their threads sleeping on chan.
 // The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
   struct proc *p;
-
+  struct thread* t;
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    for(t = p->threads ; t < &p->threads[NTHREAD] ; t++)
+      if(t->state == SLEEPING && t->chan == chan)
+        t->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
@@ -439,14 +654,16 @@ int
 kill(int pid)
 {
   struct proc *p;
-
+  struct thread* t;
   acquire(&ptable.lock);
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->pid == pid){
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
+      for(t = p->threads ; t < &p->threads[NTHREAD] ; t++){
+        if(t->state == SLEEPING)
+          t->state = RUNNABLE;
+      }
       release(&ptable.lock);
       return 0;
     }
@@ -454,6 +671,27 @@ kill(int pid)
   release(&ptable.lock);
   return -1;
 }
+  
+void printppn(pde_t* pgdir){
+  int i,j;
+  char* write;
+  pte_t* pgtable;
+  for(i=0; i<1024; i++){
+    if ((pgdir[i] & PTE_P) && (pgdir[i] & PTE_U)){
+      pgtable = (pte_t*)P2V(PTE_ADDR(pgdir[i]));
+      for (j=0; j<1024; j++){
+        if (pgtable[j] & PTE_P && pgtable[j] & PTE_U){
+          if (pgtable[j]& PTE_W){
+            write="y";
+           } 
+          else
+            write="n";
+          cprintf("%d -> %d %s\n", ((i<<10) + j), (pgtable[j] >> 12), write);   
+        }
+      }
+    }
+  }
+}
 
 //PAGEBREAK: 36
 // Print a process listing to console.  For debugging.
@@ -466,28 +704,198 @@ procdump(void)
   [UNUSED]    "unused",
   [EMBRYO]    "embryo",
   [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
+  [RUNNABLE]  "runnble",
   [RUNNING]   "run   ",
   [ZOMBIE]    "zombie"
   };
   int i;
+
   struct proc *p;
   char *state;
   uint pc[10];
-
+  struct thread* t;
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
+      continue;  
+      if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+          state = states[p->state];
+        else
+          state = "???";
+        cprintf("%d       %s %s\n", p->pid, state, p->name);
+        printppn(p->pgdir); 
+    for(t=p->threads;t<&p->threads[NTHREAD];t++)
+    {
+        
+        if(t->state == SLEEPING){
+          getcallerpcs((uint*)t->context->ebp+2, pc);
+          for(i=0; i<10 && pc[i] != 0; i++)
+            cprintf(" %p", pc[i]);
+        }
+        /*cprintf("\n");*/
+      }
+  }
+}
+
+
+void kthread_exit(){
+  acquire(&ptable.lock);
+  int i;
+  int last = -1;
+  for(i=0;i<NTHREAD;i++){
+    if(proc->threads[i].id!=thread->id&&proc->threads[i].state!=ZOMBIE&&proc->threads[i].state!=UNUSED){
+      last=i;
+      break;
+    }
+  }
+
+  if(last==-1){
+    release(&ptable.lock);
+    exit();
+  }
+  else{
+    
+    
+    //thread->kstack=0; will conflict with kfree() at wait..
+    thread->tf=0;
+    //thread->id=0; was really bad idea
+    thread->state=ZOMBIE;
+    wakeupThreads(thread);
+      // Jump into the scheduler, never to return.
+    sched();
+    panic("kthread-exit: error");
+    
+  }
+}
+
+int kthread_mutex_alloc(){
+  struct kthread_mutex_t* mutex;
+  int i;
+  acquire(&mtable.lock);
+  for(i=0;i<MAX_MUTEXES;i++){
+    if(!mtable.mutexes[i].used){
+      mtable.mutexes[i].used=1;
+      release(&mtable.lock);
+      mutex=&mtable.mutexes[i];
+      mutex->locked=0;
+      mutex->waiting=0;
+      mutex->owner=0;
+      mutex->num=0;
+      initlock(&mutex->lock,"mutexlock");
+      return i;
     }
-    cprintf("\n");
   }
+  //there is no free mutex
+  release(&mtable.lock);
+  return -1;
+
+}
+int kthread_mutex_dealloc(int mutex_id){
+  struct kthread_mutex_t* mutex=&mtable.mutexes[mutex_id];
+
+  acquire(&mtable.lock);
+  if(!mutex->used){
+    release(&mtable.lock);
+    return -1;
+  }
+  if(mutex->locked==1){
+    release(&mtable.lock);
+    return -1;
+  }
+  if(mutex->waiting){
+    release(&mtable.lock);
+    return -1;
+  }
+  mutex->used=0;
+  release(&mtable.lock);
+  return 0;
+
+
+}
+int kthread_mutex_lock(int mutex_id){
+  struct kthread_mutex_t* mutex=&mtable.mutexes[mutex_id];
+  if(!mutex)
+    return -1;
+  acquire(&mutex->lock);
+  if(!mutex->used){
+    release(&mutex->lock);
+    return -1;
+  }
+  if(mutex->locked){
+    //our implementation of watining list.. using an thread field "list" to create linked list of waiting threads.
+    thread->list=mutex->waiting;
+    mutex->waiting=thread;
+    mutex->num++;
+    sleep(thread,&mutex->lock); //moving the thread to "blocked" state. sleeping on itself.
+  }
+  else{
+    //LOCK IS MINE
+    if(mutex->num>0)
+      panic("number panic");
+    mutex->locked=1;
+    mutex->owner=thread;
+  }
+  release(&mutex->lock);
+
+  return 0;
+}
+
+//FIFO STYLE
+struct thread* getWaitingThread(struct kthread_mutex_t* mutex){
+  struct thread* ans;
+  struct thread* prev;
+  ans=mutex->waiting;
+  prev=ans;
+
+  if(!ans)
+    return 0;
+  //getting the last link in this linked list.
+  while(ans->list){
+    prev=ans;
+    ans=ans->list;
+  }
+  //Only one thread is wating
+  if(ans==prev)
+    mutex->waiting=0;
+  else
+    prev->list=0;
+  return ans;
+
+}
+
+///CONTINUE HERE !! HOPEFULLY LOCK IS WORKING FINE
+int kthread_mutex_unlock(int mutex_id){
+
+    struct kthread_mutex_t* mutex=&mtable.mutexes[mutex_id];
+    acquire(&mutex->lock);
+    if(!mutex->locked){
+      release(&mutex->lock);
+      return -1;
+    }
+    /*if(mutex->owner!=thread){
+      release(&mutex->lock);
+      panic("a thread trying to unlock mutex he does not own"); // make sure that what Vadim meant. if not, just delete this if.
+       return -1;
+
+    }*/
+    // we are actually doing fair FIFO mutex. 
+    struct thread* t = getWaitingThread(mutex);
+
+    if(t){
+      mutex->owner=t;
+      mutex->num--;
+      wakeup(t);
+    }
+    else{
+      // no thread is waiting for this lock.
+      mutex->locked=0;
+      mutex->owner=0;
+      mutex->waiting=0;
+    }
+    release(&mutex->lock);
+    return 0;
+
 }
+int kthread_mutex_num(int mutex_id){
+  struct kthread_mutex_t* mutex=&mtable.mutexes[mutex_id];
+  return mutex->num;
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 7352805..a8ce050 100644
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,7 @@
+#include "kthread.h"
+#include "spinlock.h"
+#include "x86.h"
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -11,6 +15,7 @@ struct cpu {
   // Cpu-local storage variables; see below
   struct cpu *cpu;
   struct proc *proc;           // The currently-running process.
+  struct thread *thread;          // The currently-running Thread;
 };
 
 extern struct cpu cpus[NCPU];
@@ -26,6 +31,7 @@ extern int ncpu;
 // in thread libraries such as Linux pthreads.
 extern struct cpu *cpu asm("%gs:0");       // &cpus[cpunum()]
 extern struct proc *proc asm("%gs:4");     // cpus[cpunum()].proc
+extern struct thread* thread asm("%gs:8"); // the current thread;
 
 //PAGEBREAK: 17
 // Saved registers for kernel context switches.
@@ -46,27 +52,39 @@ struct context {
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+//enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+
 
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
   pde_t* pgdir;                // Page table
-  char *kstack;                // Bottom of kernel stack for this process
   enum procstate state;        // Process state
   int pid;                     // Process ID
   struct proc *parent;         // Parent process
-  struct trapframe *tf;        // Trap frame for current syscall
-  struct context *context;     // swtch() here to run process
-  void *chan;                  // If non-zero, sleeping on chan
+  struct spinlock lock;        //lock for this proccess.
   int killed;                  // If non-zero, have been killed
+  int executed;
+  int shared;         
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  struct thread threads[NTHREAD];
+};
+struct thread* allocthread(struct proc* p);
+void execSignalToThreads(struct thread* t);
+
+struct kthread_mutex_t{
+  struct thread* owner;
+  struct thread* waiting;
+  struct spinlock lock;
+  int locked;
+  int used;
+  int num; 
 };
 
 // Process memory is laid out contiguously, low addresses first:
 //   text
 //   original data and bss
 //   fixed-size stack
-//   expandable heap
+//   expandable heap
\ No newline at end of file
diff --git a/spinlock.c b/spinlock.c
index 7b372ef..bf863ef 100644
--- a/spinlock.c
+++ b/spinlock.c
@@ -59,10 +59,8 @@ release(struct spinlock *lk)
   // stores; __sync_synchronize() tells them both to not re-order.
   __sync_synchronize();
 
-  // Release the lock, equivalent to lk->locked = 0.
-  // This code can't use a C assignment, since it might
-  // not be atomic.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+  // Release the lock.
+  lk->locked = 0;
 
   popcli();
 }
diff --git a/spinlock.h b/spinlock.h
index 0a9d8e2..808e931 100644
--- a/spinlock.h
+++ b/spinlock.h
@@ -1,3 +1,6 @@
+#ifndef SPINLOCK_H
+#define SPINLOCK_H
+
 // Mutual exclusion lock.
 struct spinlock {
   uint locked;       // Is the lock held?
@@ -9,3 +12,4 @@ struct spinlock {
                      // that locked the lock.
 };
 
+#endif
\ No newline at end of file
diff --git a/syscall.c b/syscall.c
index 5d3be9d..cc5f2d0 100644
--- a/syscall.c
+++ b/syscall.c
@@ -45,7 +45,7 @@ fetchstr(uint addr, char **pp)
 int
 argint(int n, int *ip)
 {
-  return fetchint(proc->tf->esp + 4 + 4*n, ip);
+  return fetchint(thread->tf->esp + 4 + 4*n, ip);
 }
 
 // Fetch the nth word-sized system call argument as a pointer
@@ -98,6 +98,20 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_kthread_create(void);
+extern int sys_kthread_id(void);
+extern int sys_kthread_exit(void);
+extern int sys_kthread_join(void);
+extern int sys_kthread_mutex_alloc(void);
+extern int sys_kthread_mutex_dealloc(void);
+extern int sys_kthread_mutex_lock(void);
+extern int sys_kthread_mutex_unlock(void);
+extern int sys_kthread_mutex_num(void);
+extern int sys_forkcow(void);
+extern int sys_waitcow(void);
+extern int sys_procdump(void);
+
+
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +135,19 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_kthread_create] sys_kthread_create,
+[SYS_kthread_id] sys_kthread_id,
+[SYS_kthread_exit] sys_kthread_exit,
+[SYS_kthread_join] sys_kthread_join,
+[SYS_kthread_mutex_alloc] sys_kthread_mutex_alloc,
+[SYS_kthread_mutex_dealloc] sys_kthread_mutex_dealloc,
+[SYS_kthread_mutex_lock] sys_kthread_mutex_lock,
+[SYS_kthread_mutex_unlock] sys_kthread_mutex_unlock,
+[SYS_kthread_mutex_num] sys_kthread_mutex_num,
+[SYS_forkcow]    sys_forkcow,
+[SYS_waitcow]    sys_waitcow,
+[SYS_procdump]   sys_procdump,
+
 };
 
 void
@@ -128,12 +155,12 @@ syscall(void)
 {
   int num;
 
-  num = proc->tf->eax;
+  num = thread->tf->eax;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    proc->tf->eax = syscalls[num]();
+    thread->tf->eax = syscalls[num]();
   } else {
     cprintf("%d %s: unknown sys call %d\n",
             proc->pid, proc->name, num);
-    proc->tf->eax = -1;
+    thread->tf->eax = -1;
   }
 }
diff --git a/syscall.h b/syscall.h
index bc5f356..aa2ef69 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,16 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_kthread_create 22
+#define SYS_kthread_id 23
+#define SYS_kthread_exit 24
+#define SYS_kthread_join 25
+#define SYS_kthread_mutex_alloc 26
+#define SYS_kthread_mutex_dealloc 27
+#define SYS_kthread_mutex_lock 28
+#define SYS_kthread_mutex_unlock 29
+#define SYS_kthread_mutex_num 30
+#define SYS_forkcow 	31
+#define SYS_waitcow		32
+#define SYS_procdump	33
+ 
diff --git a/sysproc.c b/sysproc.c
index 6b585e0..fa0c9ef 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,81 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+int sys_kthread_create(void){
+  void*(*start_func)();
+  void* stack;
+  int stack_size;
+
+  if(argint(0, (int*)&start_func) < 0)
+    return -1;
+  if(argint(1, (int*)&stack) < 0)
+    return -1;
+  if(argint(2, (int*)&stack_size) < 0)
+    return -1;
+
+  return kthread_create(start_func, stack, stack_size);
+}
+
+int sys_kthread_id(void){
+  return kthread_id();
+}
+
+int sys_kthread_exit(void){
+  kthread_exit();
+  return 0;
+}
+
+int sys_kthread_join(void){
+  int kthread_id;
+  if(argint(0, &kthread_id) < 0)
+    return -1;
+  kthread_join(kthread_id);
+  return 0;
+}
+int sys_kthread_mutex_alloc(){
+  return kthread_mutex_alloc();
+}
+int sys_kthread_mutex_dealloc(){
+  int mutex_id;
+  if(argint(0, &mutex_id) < 0)
+    return -1;
+  return kthread_mutex_dealloc(mutex_id);
+}
+int sys_kthread_mutex_lock(){
+  int mutex_id;
+  if(argint(0, &mutex_id) < 0)
+    return -1;
+  return kthread_mutex_lock(mutex_id);
+}
+int sys_kthread_mutex_unlock(){
+  int mutex_id;
+  if(argint(0, &mutex_id) < 0)
+    return -1;
+  return kthread_mutex_unlock(mutex_id);
+}
+
+int sys_kthread_mutex_num(){
+  int mutex_id;
+  if(argint(0, &mutex_id) < 0)
+    return -1;
+  return kthread_mutex_num(mutex_id);
+}
+
+int
+sys_forkcow(void)
+{
+  return forkcow();
+}
+
+int
+sys_waitcow(void)
+{
+  return waitcow();
+}
+
+int
+sys_procdump(void)
+{
+  procdump();
+  return 0;
+}
\ No newline at end of file
diff --git a/threadtest.c b/threadtest.c
new file mode 100644
index 0000000..2d28a9a
--- /dev/null
+++ b/threadtest.c
@@ -0,0 +1,34 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "syscall.h"
+
+void
+run(){
+	int id = kthread_id();
+	int pid = getpid();
+	int i, j;
+	printf(1, "my id: %d\n", id);
+	printf(1,"my pid: %d\n", pid);
+	for(i=0; i<100000;i++)
+		for(j=0; j<400;j++)
+			id++;
+	printf(1,"hey");
+	kthread_exit();
+}
+
+int
+main(int argc, char *argv[])
+{
+	void* stack = (void*)malloc(4000);
+	void*(*start_func)();
+	start_func = (void*)&run;
+	int pid = getpid();
+	printf(1, "%d\n",pid);
+	int tid = kthread_create(start_func, stack, 4000);
+	int rest = kthread_join(tid);
+	//int rest = 0;
+	printf(1, "result: %d, tid: %d\n", rest, tid);
+	exit();
+}
\ No newline at end of file
diff --git a/threadtest1.c b/threadtest1.c
new file mode 100644
index 0000000..29948be
--- /dev/null
+++ b/threadtest1.c
@@ -0,0 +1,32 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "kthread.h"
+void * print_id(void)
+{
+	printf(1,"Thread id is: %d\n",kthread_id());
+	
+	sleep(1000);
+	printf(1,"Thread is exiting.\n");
+	kthread_exit();
+	return (void *) 1;
+}
+int main()
+{
+	int tid1,tid2;
+	char stack1[1024];
+	char stack2[1024];
+	
+	tid1=kthread_create(&print_id,stack1,1024);
+	
+	tid2=kthread_create(&print_id,stack2,1024);
+	
+	kthread_join(tid1);
+	printf(1,"Got id : %d \n",tid1);
+	kthread_join(tid2);
+	printf(1,"Got id : %d \n",tid2);
+	printf(1,"Finished.\n");
+	sleep(500);
+	kthread_exit();
+	return 1;
+}
\ No newline at end of file
diff --git a/threadtest2.c b/threadtest2.c
new file mode 100644
index 0000000..08a5492
--- /dev/null
+++ b/threadtest2.c
@@ -0,0 +1,23 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "kthread.h"
+void* printBLABLA()
+{
+	printf(1,"blabla.\n");
+	sleep(500);
+	exit();
+}
+int main(void)
+{
+	char stack1 [1024];
+	char stack2 [1024];
+	/*int tid1,tid2;*/
+	kthread_create(&printBLABLA,stack1,1024);
+	kthread_create(&printBLABLA,stack2,1024);
+	/*printf(1,"tid1 is: %d.\n",tid1);
+	printf(1,"tid2 is: %d.\n",tid2);
+	printf(1,"pid: %d.\n",getpid());*/
+	sleep(500);
+	exit();
+}
\ No newline at end of file
diff --git a/threadtest4.c b/threadtest4.c
new file mode 100644
index 0000000..9add826
--- /dev/null
+++ b/threadtest4.c
@@ -0,0 +1,53 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "kthread.h"
+ 
+void* printme() {
+  printf(1,"Thread %d running !\n", kthread_id());
+  kthread_exit();
+  return 0;
+}
+#define MAX_STACK_SIZE 4096
+int
+main(int argc, char *argv[])
+{
+  uint *stack, *stack1, *stack2;
+  int tid, tid1, tid2;
+ 
+  stack = malloc(MAX_STACK_SIZE);
+  memset(stack, 0, sizeof(*stack));
+  if ((tid = (kthread_create(printme, stack, MAX_STACK_SIZE))) < 0) {
+    printf(2, "thread_create error\n");
+  }
+  stack1  = malloc(MAX_STACK_SIZE);
+  memset(stack1, 0, sizeof(*stack1));
+  if ((tid1 = (kthread_create(printme, stack1, MAX_STACK_SIZE))) < 0) {
+    printf(2, "thread_create error\n");
+  }
+  stack2  = malloc(MAX_STACK_SIZE);
+  memset(stack2, 0, sizeof(*stack2));
+  if ((tid2 = (kthread_create(printme, stack2, MAX_STACK_SIZE))) < 0) {
+    printf(2, "thread_create error\n");
+  }
+  printf(1, "Joining %d\n", tid);
+  if (kthread_join(tid) < 0) {
+    printf(2, "join error\n");
+  }
+ 
+  printf(1, "Joining %d\n", tid1);
+  if (kthread_join(tid1) < 0) {
+    printf(2, "join error\n");
+  }
+ 
+ 
+  printf(1, "Joining %d\n", tid2);
+  if (kthread_join(tid2) < 0) {
+    printf(2, "join error\n");
+  }
+ 
+ 
+  printf(1, "\nAll threads done!\n");
+ 
+  exit();
+}
\ No newline at end of file
diff --git a/trap.c b/trap.c
index e6b3784..0c19c22 100644
--- a/trap.c
+++ b/trap.c
@@ -37,12 +37,16 @@ void
 trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
-    if(proc->killed)
+    if(proc->killed||proc->executed)
       exit();
-    proc->tf = tf;
+    if(thread->killed)
+      kthread_exit();
+    thread->tf = tf;
     syscall();
-    if(proc->killed)
+    if(proc->killed||proc->executed)
       exit();
+    if(thread->killed)
+      kthread_exit();
     return;
   }
 
@@ -77,6 +81,11 @@ trap(struct trapframe *tf)
             cpunum(), tf->cs, tf->eip);
     lapiceoi();
     break;
+  case T_PGFLT:
+    if (proc->shared == 1 && copyuvmcow() != 0) {
+      break;
+    }
+    panic("T_PGFLT - cannot alloc while shared");
 
   //PAGEBREAK: 13
   default:
@@ -92,20 +101,26 @@ trap(struct trapframe *tf)
             proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
             rcr2());
     proc->killed = 1;
+    struct thread* t;
+    for(t = proc->threads ; t < &proc->threads[NTHREAD] ; t++){
+      if(t->state == SLEEPING)
+        t->state = RUNNABLE;
+    }
   }
 
+
   // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
+  // (If it is still executing in the kernel, let it keep running 
   // until it gets to the regular system call return.)
-  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+  if(proc && (proc->killed || proc->executed) && (tf->cs&3) == DPL_USER) 
     exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
+  if(thread && thread->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
     yield();
 
   // Check if the process has been killed since we yielded
-  if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+  if(proc && (proc->killed || proc->executed) && (tf->cs&3) == DPL_USER)  
     exit();
 }
diff --git a/ttest.c b/ttest.c
new file mode 100644
index 0000000..845c23d
--- /dev/null
+++ b/ttest.c
@@ -0,0 +1,62 @@
+// Test that fork fails gracefully.
+// Tiny executable so that the limit can be filling the proc table.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "syscall.h"
+
+#define STK_SIZE 4096
+
+void test1(void);
+void* test1_threadfunc();
+
+int tester;
+
+int main(void){
+  int pid;
+  pid = fork();
+  if(pid == 0){
+  	test1();
+  	printf(1, "SHOULDNT BE HERE\n");
+  	exit();
+  }
+  else
+  	wait();
+  exit();
+}
+
+void test1(void){
+	tester = -1;
+	printf(1, "test 1 - start:\n");
+	void *stack = malloc(STK_SIZE);
+	int tid = kthread_id();
+	int new_tid = kthread_create(test1_threadfunc, stack, STK_SIZE);
+	
+	if(new_tid<0){
+		printf(1, "TEST 1.a. FAILED - thread was not created\n");
+		exit();
+	}
+
+	//thread was created
+	printf(1, "join = %d\n", kthread_join(new_tid));
+	if(tester == -1)
+		printf(1, "TEST 1.b. FAILED - kthread_join not waiting\n");
+	else
+		printf(1, "TEST 1.b. PASSED - thread #%d joined with #%d\n", tid, new_tid);
+	if(tester == 1)
+		printf(1, "TEST 1.c PASSED - thread exit with kthread_exit()\n");
+
+	printf(1, "test 1 - end\n");
+	kthread_exit();
+}
+
+void* test1_threadfunc(){
+	int tid = kthread_id();
+	printf(1, "TEST 1.a. PASSED - thread #%d created succesfully\n", tid);
+	tester = 1;
+	kthread_exit();
+	tester = 0;
+	printf(1, "TEST 1.c FAILED - thread #%d was not exit with kthread_exit()\n", tid);
+	exit();
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index f45b8d5..f6aaec9 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,18 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int kthread_create(void* (start_func)(),void* stack,int stack_size);
+int kthread_id();
+void kthread_exit();
+int kthread_join();
+int kthread_mutex_alloc();
+int kthread_mutex_dealloc(int);
+int kthread_mutex_lock(int);
+int kthread_mutex_unlock(int);
+int kthread_mutex_num(int);
+int forkcow(void);
+int waitcow(void);
+void procdump(void);
 
 // ulib.c
 int stat(char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..078cf31 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,16 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(kthread_create);
+SYSCALL(kthread_id);
+SYSCALL(kthread_exit);
+SYSCALL(kthread_join);
+SYSCALL(kthread_mutex_alloc);
+SYSCALL(kthread_mutex_dealloc);
+SYSCALL(kthread_mutex_lock);
+SYSCALL(kthread_mutex_unlock);
+SYSCALL(kthread_mutex_num);
+SYSCALL(forkcow);
+SYSCALL(waitcow);
+SYSCALL(procdump);
+
diff --git a/vm.c b/vm.c
index d9aaa7e..0c2e92f 100644
--- a/vm.c
+++ b/vm.c
@@ -28,7 +28,7 @@ seginit(void)
   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
 
   // Map cpu and proc -- these are private per cpu.
-  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+  c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 12, 0);
 
   lgdt(c->gdt, sizeof(c->gdt));
   loadgs(SEG_KCPU << 3);
@@ -36,6 +36,7 @@ seginit(void)
   // Initialize cpu-local storage.
   cpu = c;
   proc = 0;
+  thread=0;
 }
 
 // Return the address of the PTE in page table pgdir
@@ -167,7 +168,7 @@ switchuvm(struct proc *p)
   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
   cpu->gdt[SEG_TSS].s = 0;
   cpu->ts.ss0 = SEG_KDATA << 3;
-  cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
+  cpu->ts.esp0 = (uint)thread->kstack + KSTACKSIZE;
   // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
   // forbids I/O instructions (e.g., inb and outb) from user space
   cpu->ts.iomb = (ushort) 0xFFFF;
@@ -391,3 +392,163 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
 //PAGEBREAK!
 // Blank page.
 
+struct entry
+{
+  // struct spinlock lock;
+  int count;
+} referenceTable[60 * 1024]; // table for all pages, upto 240MB(PHYSTOP)
+
+struct spinlock referencelock; // lock for share table
+
+void
+referenceTableinit(void)
+{
+  initlock(&referencelock, "referenceTable");
+  // cprintf("share table init done\n");
+}
+
+
+//crucial function. shallow copy of the pages instead of creating new ones.
+pde_t* cowmapuvm(pte_t* pgdir,uint size){
+  pde_t *d;
+  pte_t *pte;
+  uint pa, i, flags;
+  int page;
+   if((d = setupkvm()) == 0)
+    return 0;
+  acquire(&referencelock);
+  for(i = 0; i < size; i += PGSIZE){
+    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+      panic("copyuvm: pte should exist");
+    if(!(*pte & PTE_P))
+      panic("copyuvm: page not present");
+    *pte &= ~PTE_W; // disable the Writable bit
+    pa = PTE_ADDR(*pte);
+    flags = PTE_FLAGS(*pte);
+
+    // instead of create new pages, remap the pages for cow child
+    if(mappages(d, (void*)i, PGSIZE, pa, flags) < 0)
+      goto bad;
+
+    page = (pa >> 12) & 0xFFFFF; // get the physical page num
+    if (referenceTable[page].count == 0) {
+      referenceTable[page].count = 2; // now is shared, totally 2 processes
+    }
+    else {
+      referenceTable[page].count++; // increase the share count
+    }
+    
+    // cprintf("pid: %d index: %d count: %d\n", proc->pid, index, referenceTable[index].count);
+  }
+  release(&referencelock);
+  lcr3(V2P(proc->pgdir)); // flush the TLB  
+  return d;
+
+bad:
+  freevm(d);
+  return 0;
+}
+
+
+//splits the pages and make them writeable.
+int copyuvmcow(void)
+{
+  // cprintf("in cow copy, index: %d\n", index);
+
+  uint pa;
+  int page;
+  uint addr;
+  pte_t *pte;
+  char *mem;
+  addr = rcr2();
+  pte = walkpgdir(proc->pgdir, (void *) addr, 0);
+  pa = PTE_ADDR(*pte);
+  page = (pa >> 12) & 0xFFFFF; // get the physical page num
+
+  // check if the address is in this process's user space
+  if (addr < proc->sz) {
+    acquire(&referencelock);
+
+    // if there are still multiple processes using this space
+    if (referenceTable[page].count > 1) {
+      if((mem = kalloc()) == 0) // allcoate a new page in physical memory
+        goto bad;
+      memmove(mem, (char*)P2V(pa), PGSIZE); // copy the page
+      *pte &= 0xFFF; // reset the first 12 bits of the entry
+      *pte |= V2P(mem) | PTE_W; // insert the new physical page num and set to writable
+
+      --referenceTable[page].count; // decrease the share count
+    }
+    // if there is only one process using this space. no need to create new pages..
+    else {
+      *pte |= PTE_W; // just enable the Writable bit for this process
+    }
+
+    release(&referencelock);
+    lcr3(V2P(proc->pgdir)); // flush the TLB
+    return 1;
+  }
+
+bad:
+  return 0;
+} 
+
+// Deallocate user pages to bring the process size from oldsz to
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+// this function is similar to DeallocUVM . adjusted to COW mechanism
+int
+deallocuvmcow(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  pte_t *pte;
+  uint a, pa;
+  int page;
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+  acquire(&referencelock);
+  for(; a < oldsz; a += PGSIZE){
+    pte = walkpgdir(pgdir, (char*)a, 0);
+    if(!pte)
+      a += (NPTENTRIES - 1) * PGSIZE;
+    else if((*pte & PTE_P) != 0){
+      pa = PTE_ADDR(*pte);
+      page = (pa >> 12) & 0xFFFFF; // get the physical page num
+      if(pa == 0)
+        panic("kfree");
+      // if there are more than one process sharing the space, decrease the counter
+      if (referenceTable[page].count > 1) {
+        --referenceTable[page].count;
+      }
+      // if the memory space is only used by this process, free it
+      else {
+        char *v = P2V(pa);
+        kfree(v);
+        referenceTable[page].count = 0;
+      }
+      *pte = 0;
+    }
+  }
+  release(&referencelock);
+  return newsz;
+}
+
+void
+freeuvmcow(pde_t *pgdir)
+{
+  uint i;
+
+  if(pgdir == 0)
+    panic("freevm: no pgdir");
+  deallocuvmcow(pgdir, KERNBASE, 0); // the only change from freeuvm
+  for(i = 0; i < NPDENTRIES; i++){
+    if(pgdir[i] & PTE_P){
+      char *v = P2V(PTE_ADDR(pgdir[i]));
+      kfree(v);
+    }
+  }
+  kfree((char*)pgdir);
+}
\ No newline at end of file
diff --git a/x86.h b/x86.h
index 07312a5..767fd8e 100644
--- a/x86.h
+++ b/x86.h
@@ -1,5 +1,5 @@
 // Routines to let C code use special x86 instructions.
-
+#pragma once
 static inline uchar
 inb(ushort port)
 {
